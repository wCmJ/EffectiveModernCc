- 阻塞和非阻塞的概念作用于所有文件描述符
- 阻塞文件描述符为阻塞I/O
- 非阻塞文件描述符为非阻塞I/O
- 针对阻塞IO执行系统调用，可能因为无法立即完成而被操作系统挂起，直到等待的事件发生
- 网络编程中可能阻塞的系统调用包括：accept, send, recv, connect
- 非阻塞总是立即返回，不管事件是否发生。如果没有发送，返回-1
- 对于accept，send，recv而言，事件未发生时errno通常被置为EAGAIN或者EWOULDBLOCK
- 对connect而言，errno被置为EINPROGRESS
- 非阻塞IO通常要与其他IO通知机制一起使用，比如IO复用和SIGIO信号


### 阻塞IO/非阻塞IO =》非阻塞IO与IO通知机制一起使用 =》 IO复用与SIGIO信号
- IO复用：应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序
  - IO复用函数提供事件注册，事件通知功能
  - IO复用函数本身是阻塞的，提高效率的原因在于具有同时监听多个IO事件的能力
  - IO复用函数有：select，poll，epoll_wait

- SIGIO
  1. 为fd指定宿主进程
  2. 宿主进程设置SIGIO处理函数
  3. 当fd上有事件发生时，宿主进程将收到SIGIO信号，并调用处理函数

### 同步IO模型
- 阻塞IO，IO复用和信号驱动IO都是同步IO模型
- 原因：IO的读写操作，都是在IO事件发生之后，由应用程序来完成

### 异步IO模型
- 对异步IO而言，用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO操作完成之后内核通知应用程序的方式
- 异步IO的读写操作总是立即返回，而不论IO是否是阻塞的，因为真正的读写操作已经由内核接管

### 同步IO VS 异步IO
- 同步IO模型要求用户代码自行执行IO操作（将数据从内核缓冲区读入用户缓冲区，或者将数据从用户缓冲区写入内核缓冲区）
- 异步IO机制由内核执行IO操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在后台完成的）
- 同步IO向应用程序通知的是IO就绪事件
- 异步IO向应用程序通知的是IO完成事件
