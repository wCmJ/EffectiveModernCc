- 阻塞和非阻塞的概念作用于所有文件描述符
- 阻塞文件描述符为阻塞I/O
- 非阻塞文件描述符为非阻塞I/O
- 针对阻塞IO执行系统调用，可能因为无法立即完成而被操作系统挂起，直到等待的事件发生
- 网络编程中可能阻塞的系统调用包括：accept, send, recv, connect
- 非阻塞总是立即返回，不管事件是否发生。如果没有发送，返回-1
- 对于accept，send，recv而言，事件未发生时errno通常被置为EAGAIN或者EWOULDBLOCK
- 对connect而言，errno被置为EINPROGRESS
- 非阻塞IO通常要与其他IO通知机制一起使用，比如IO复用和SIGIO信号


### 阻塞IO/非阻塞IO =》非阻塞IO与IO通知机制一起使用 =》 IO复用与SIGIO信号
- IO复用：应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序
  - IO复用函数提供事件注册，事件通知功能
  - IO复用函数本身是阻塞的，提高效率的原因在于具有同时监听多个IO事件的能力
  - IO复用函数有：select，poll，epoll_wait

- SIGIO
  1. 为fd指定宿主进程
  2. 宿主进程设置SIGIO处理函数
  3. 当fd上有事件发生时，宿主进程将收到SIGIO信号，并调用处理函数

### 同步IO模型
- 阻塞IO，IO复用和信号驱动IO都是同步IO模型
- 原因：IO的读写操作，都是在IO事件发生之后，由应用程序来完成

### 异步IO模型
- 对异步IO而言，用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO操作完成之后内核通知应用程序的方式
- 异步IO的读写操作总是立即返回，而不论IO是否是阻塞的，因为真正的读写操作已经由内核接管

### 同步IO VS 异步IO
- 同步IO模型要求用户代码自行执行IO操作（将数据从内核缓冲区读入用户缓冲区，或者将数据从用户缓冲区写入内核缓冲区）
- 异步IO机制由内核执行IO操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在后台完成的）
- 同步IO向应用程序通知的是IO就绪事件
- 异步IO向应用程序通知的是IO完成事件

| IO模型 | 读写操作和阻塞阶段 |
| :---: | :---:|
| 阻塞IO | 阻塞与读写阶段 |
| IO复用 | 阻塞与IO复用系统调用，但可同时监听多个IO事件，对IO本身的读写操作是非阻塞的 |
| SIGIO信号 | 信号触发读写事件，用户程序执行读写操作，没有阻塞阶段 | 
| 异步IO | 内核执行读写操作并触发读写完成时间，没有阻塞阶段 |


## 高效处理的事件处理模式
- 服务器通常处理三类事件：IO事件、信号及定时事件
- 网络设计模式的兴起，Reactor和Proactor事件处理模式诞生
- 同步IO模型通常用于实现Reactor模式
- 异步IO模型则用于实现Proactor模式

### Reactor模式
- 该模式要求主线程（IO处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成
- 使用同步IO模型实现的Reactor模式的工作流程是：
  1. 主线程往epoll内核时间表中注册socket上的读就绪事件
  2. 主线程调用epoll_wait等待socket上有数据可读
  3. 当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列
  4. 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
  5. 主线程调用epoll_wait等待socket可写
  6. 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
  7. 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

### Proactor模式
- 将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑
- 使用异步IO模型实现的Proactor模式的工作流程：
  1. 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序
  2. 主线程继续处理其他逻辑
  3. 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据以及可用
  4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求，工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）
  5. 主线程继续处理其他逻辑
  6. 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕
  7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理


## 两种高效的并发模式
- 并发的目的是让程序同时执行多个任务，如果程序是计算密集型的，并发编程并没有优势，如果程序是IO密集型的，比如经常读写文件，访问数据库等
- 从实现上讲，并发编程有多进程和多线程两种方式

### 并发模式是指IO处理单元和多个逻辑单元之间协调完成任务的办法
#### 半同步/半异步模式



#### 领导者/追随者模式



















