- 阻塞和非阻塞的概念作用于所有文件描述符
- 阻塞文件描述符为阻塞I/O
- 非阻塞文件描述符为非阻塞I/O
- 针对阻塞IO执行系统调用，可能因为无法立即完成而被操作系统挂起，直到等待的事件发生
- 网络编程中可能阻塞的系统调用包括：accept, send, recv, connect
- 非阻塞总是立即返回，不管事件是否发生。如果没有发送，返回-1
- 对于accept，send，recv而言，事件未发生时errno通常被置为EAGAIN或者EWOULDBLOCK
- 对connect而言，errno被置为EINPROGRESS
- 非阻塞IO通常要与其他IO通知机制一起使用，比如IO复用和SIGIO信号


### 阻塞IO/非阻塞IO =》非阻塞IO与IO通知机制一起使用 =》 IO复用与SIGIO信号
- IO复用：应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中就绪的事件通知给应用程序
  - IO复用函数提供事件注册，事件通知功能
  - IO复用函数本身是阻塞的，提高效率的原因在于具有同时监听多个IO事件的能力
  - IO复用函数有：select，poll，epoll_wait

- SIGIO
  1. 为fd指定宿主进程
  2. 宿主进程设置SIGIO处理函数
  3. 当fd上有事件发生时，宿主进程将收到SIGIO信号，并调用处理函数

### 同步IO模型
- 阻塞IO，IO复用和信号驱动IO都是同步IO模型
- 原因：IO的读写操作，都是在IO事件发生之后，由应用程序来完成

### 异步IO模型
- 对异步IO而言，用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO操作完成之后内核通知应用程序的方式
- 异步IO的读写操作总是立即返回，而不论IO是否是阻塞的，因为真正的读写操作已经由内核接管

### 同步IO VS 异步IO
- 同步IO模型要求用户代码自行执行IO操作（将数据从内核缓冲区读入用户缓冲区，或者将数据从用户缓冲区写入内核缓冲区）
- 异步IO机制由内核执行IO操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在后台完成的）
- 同步IO向应用程序通知的是IO就绪事件
- 异步IO向应用程序通知的是IO完成事件

| IO模型 | 读写操作和阻塞阶段 |
| :---: | :---:|
| 阻塞IO | 阻塞与读写阶段 |
| IO复用 | 阻塞与IO复用系统调用，但可同时监听多个IO事件，对IO本身的读写操作是非阻塞的 |
| SIGIO信号 | 信号触发读写事件，用户程序执行读写操作，没有阻塞阶段 | 
| 异步IO | 内核执行读写操作并触发读写完成时间，没有阻塞阶段 |


## 高效处理的事件处理模式
- 服务器通常处理三类事件：IO事件、信号及定时事件
- 网络设计模式的兴起，Reactor和Proactor事件处理模式诞生
- 同步IO模型通常用于实现Reactor模式
- 异步IO模型则用于实现Proactor模式

### Reactor模式
- 该模式要求主线程（IO处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成
- 使用同步IO模型实现的Reactor模式的工作流程是：
  1. 主线程往epoll内核时间表中注册socket上的读就绪事件
  2. 主线程调用epoll_wait等待socket上有数据可读
  3. 当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列
  4. 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
  5. 主线程调用epoll_wait等待socket可写
  6. 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
  7. 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

### Proactor模式
- 将所有IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑
- 使用异步IO模型实现的Proactor模式的工作流程：
  1. 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序
  2. 主线程继续处理其他逻辑
  3. 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据以及可用
  4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求，工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）
  5. 主线程继续处理其他逻辑
  6. 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕
  7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理


## 两种高效的并发模式
- 并发的目的是让程序同时执行多个任务，如果程序是计算密集型的，并发编程并没有优势，如果程序是IO密集型的，比如经常读写文件，访问数据库等
- 从实现上讲，并发编程有多进程和多线程两种方式

### 并发模式是指IO处理单元和多个逻辑单元之间协调完成任务的办法
#### 半同步/半异步模式



#### 领导者/追随者模式


## 服务器调制、调试及压测
- 系统调制、服务器调试及压力测试
- Linux平台可以通过修改文件的方式来调整内核参数，系统或进程能打开的最大文件描述符数尤其重要
- 碰到问题意外时，一种调试方法是利用tcpdump抓包，对于服务器逻辑错误，更方便的调试方法是gdb调试器
- 编写压力测试工具

### 最大文件描述符数
- 文件描述符是服务器程序的宝贵资源，系统分配给应用程序的文件描述符数量是有限制的，所以必须总是关闭那些已经不再使用的文件描述符，以释放它们占用的资源
- 作为守护进程运行的服务器程序应该总是关闭标准输入、标准输出和标准错误输出
- Linux对于应用程序能打开的最大文件描述符数量有两个层次的限制
  - 用户级限制：目标用户运行的所有进程总共能打开的文件描述符数. ulimit -n or /etc/security/limits.conf
  - 系统级限制：所有用户能打开的文件描述符数

- /proc/sys/fs/file-max：系统级文件描述符限制
- /proc/sys/fs/epoll/max_user_watches：一个用户能够往epoll内核事件表中注册的事件的总量
- /proc/sys/net/core/somaxconn：监听队列中，能够建立完整连接而进入established状态的socket的最大数目
- /proc/sys/net/ipv4/tcp_max_syn_backlog：listen监听队列中，能够转移至EStablished或者SYN_RCVD状态的socket的最大数目
- /proc/sys/net/ipv4/tcp_wmem：写缓冲区的最小值、默认值和最大值
- /proc/sys/net/ipv4/tcp_rmem：读缓冲区的最小值，默认值和最大值
- /proc/sys/net/ipv4/tcp_syncookies：通过启动cookie来防止一个监听socket因不停地重复接收来自同一个地址的连接请求，而导致listen监听队列溢出
- 永久生效：写入sysctl.conf中，且执行sysctl -p来生效

### gdb调试多进程
- 一个进程通过fork系统调用创建了子进程，gdb会继续调试原来的进程，子进程正常运行，如何调试子进程？
  1. 单独调试子进程
    - 找到子进程PID
    - 1. gdb；2. attach PID
  2. 使用调试选项follow-fork-mode
    - follow-fork-mode运行我们选择程序在执行fork后是继续调试父进程还是调试子进程
    - 使用方法：1. gdb ./app; 2. set follow-fork-mode child/parent; 

### gdb调试多线程
- gdb有一组命令可辅助多线程程序的调试
- info threads：显示当前可调式的所有线程，gdb会为每个线程分配一个ID，为*的表示当前线程
- thread ID：调试目标ID的线程
- set scheduler-locking[off|on|step]：调试多线程程序时，默认除了被调试的线程在执行外，其他线程也在继续执行，有时候希望只有被调试的线程执行，可以通过该命令实现
  - off：不锁定任何线程，即所有线程都可执行，默认值
  - on：只有当前被调试的线程会继续执行
  - step：在单步执行的时候，只有当前线程会执行
  - 1. gdb ./app; 2. info threads; 3. set scheduler-locking on(不执行其他线程，锁定调试对象); 4. thread 2; 5. bt;

### 调试进程池或者线程池
- 一个不错的方法是：先将池中的进程个数或线程个数减少至1，以观察程序的逻辑是否正确，然后再逐步增加

































