## 可执行文件的装载与进程
- 加载进内存
- 为了将进程隔离（为什么要隔离？防止硬件、资源冲突，与实际的内存解绑。如何隔离？增加中间层，每个进程拥有自己的虚拟地址空间，大小由地址总线决定，维持虚拟地址与物理地址映射关系。进程不用关心实际的物理内存情况）
- 装载方法：静态与动态
  - 静态：将代码与数据全部装入内存
  - 动态：覆盖装载与页映射
    - 覆盖装载：不使用且相互之间没有依赖关系的模块可以使用相同物理地址
    - 页映射：将可执行文件、虚拟地址空间、物理地址以页的方式划分，以页的形式加载
  - 页映射
    - 虚拟地址空间与可执行文件的映射关系（缺页时通过此映射关系找到可执行文件的对应内容，内存中以VMA形式保存）
    - 虚拟地址空间与物理内存的映射关系（缺页时分配、建立映射）
  - 进程具体装载过程
    - 进程建立
      1. 创建独立的虚拟地址空间，建立虚拟地址空间与物理内存的映射关系，实际上并不是创建空间而是建立映射函数需要的数据结构，分配页表（可在发生页错误的时候再建立关系）
      2. 读取可执行文件，建立虚拟空间与可执行文件的映射关系
      3. 将CPU的指令设置成可执行文件的入口地址，启动运行
    - Linux将进程虚拟空间中的一个段叫做虚拟内存区域VMA，操作系统创建进程后，会在进程相应的数据结构中设置有一个.text段的VMA（虚拟空间地址、可执行文件地址，属性等）
    - 缺页处理
      1. 触发缺页中断
      2. 缺页处理程序查询数据结构，找到空页面所在的VMA，计算出页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，建立虚拟地址空间与物理页的映射关系
    - 可执行文件中段的数量过多，单独对应页时产生较大的空间浪费，并且操作系统不关心段的内容，只关心段的属性（权限），可以将相同属性的段进行合并
      - 权限：可读可写，可读可执行，只读
      - 对于相同权限的段，合并到一起当做一个段进行映射
      
- Linux内核装载ELF过程
1. bash下输入指令
2. bash调用fork并执行execve加载新的可执行文件
3. execve调用do_execve，首先查找被执行的文件，如果找到文件，读取文件的前128个字节判断文件格式。（Linux支持的可执行文件格式不知ELF一种，还有a.out和Java及#！开始的脚本程序）
   每种可执行文件的格式的开头几个字节都是很特殊的，特别是开头4个字节，常常被称作魔数，通过对魔数的判断可以确定文件的格式和类型。
   ELF: 0x7F, e, l, f
   Java: c, a, f, e
   脚本：#！
   
   
   
## 动态链接
- 静态链接：空间浪费，更新、部署和发布困难，由静态链接器ld完成
- 动态链接：不对那些组成程序的目标文件进行链接，等到程序运行时才进行链接，把整个链接过程推迟到运行期再进行
   
- 基本实现
  - g++ -fPIC -shared -o libxxx.so xxx.c
  - 动态链接涉及运行时的链接及多个文件的装载，必须要有操作系统的支持
  - 动态链接在每次执行前需要进行动态库装载、符号绑定及重定位工作，性能比静态链接低，通过优化（延迟绑定Lazy Binding）可将性能损耗控制在5%下
  - 静态链接时，链接器会按照静态链接的规则，将地址重定位
  - 动态链接时，链接器会将该符号的引用标记为一个动态链接的符号，不进行重定位。如何判断符号是静态符号和动态符号？链接时引入so作为输入，so中保存了完整的符号信息
   
  - 共享对象的最终装载地址在编译时是不确定的
  - readelf -l libxxx.so查看segment信息
  - readelf -S elf_file 查看section信息   
   
   
- 地址无关代码
  -    
   
   
   
   
   
   

